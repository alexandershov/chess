**0..7 or 1..8 for Board indices?**

* âŒ0..7
    * ğŸ™‚Zero-based indexing is more common 
    * ğŸ˜¡Not as on real board
* âœ…1..8
    * ğŸ™‚Same as on real board
    * ğŸ™‚Looks like one-based indexing is not bad here and plays nicely with inclusive ranges in Haskell
    * ğŸ˜¡One-based indexing

**How to name which side is to move in Position?**

* âœ…sideToMove
    * ğŸ™‚Clear and most popular
    * ğŸ˜¡Pretty long
* âŒtoMove
    * ğŸ˜¡Unclear
* âŒmoveOrder
    * ğŸ˜¡Unclear
    * ğŸ˜¡Reads like a verb
* âŒactiveSide
    * ğŸ˜¡Unclear

**How to represent move**?
* âŒdata Move = Move Square Square
    * ğŸ˜¡Move can change castling, en passant etc
* âŒdata Move = Move Square Square | Castle | 
    * ğŸ˜¡What about en passant etc?
* âŒdata Move = Move { from::Square, to::Square, isCapture::Bool, castleModifiers, ...}
    * ğŸ˜¡There are gonna be many modifiers
* âœ…data Move = Move { from::Square, to::Square, promotion: Maybe Piece, Position -> Position}
    * ğŸ™‚General enough
    * ğŸ™‚from, to, and promotion will help to debug
* âŒdata Move = Move {Position -> Position, stringRepresentation}
    * ğŸ˜¡Move generator will need to know about string representation
* âŒtype Move = Position -> Position
    * ğŸ™‚Very cool and general
    * ğŸ˜¡Hard to debug
