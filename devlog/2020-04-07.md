**0..7 or 1..8 for Board indices?**
* âŒ0..7
    * ðŸ™‚Zero-based indexing is more common 
    * ðŸ˜¡Not as on real board
* âœ…1..8
    * ðŸ™‚Same as on real board
    * ðŸ™‚Looks like one-based indexing is not bad here and plays nicely with inclusive ranges in Haskell
    * ðŸ˜¡One-based indexing

**How to name which side is to move in Position?**
* âœ…sideToMove
    * ðŸ™‚Clear and most popular
    * ðŸ˜¡Pretty long
* âŒtoMove
    * ðŸ˜¡Unclear
* âŒmoveOrder
    * ðŸ˜¡Unclear
    * ðŸ˜¡Reads like a verb
* âŒactiveSide
    * ðŸ˜¡Unclear

**How to represent move**?
* âŒdata Move = Move Square Square
    * ðŸ˜¡Move can change castling, en passant etc
* âŒdata Move = Move Square Square | Castle | 
    * ðŸ˜¡What about en passant etc?
* âŒdata Move = Move { from::Square, to::Square, isCapture::Bool, castleModifiers, ...}
    * ðŸ˜¡There are gonna be many modifiers
* âŒâœ…data Move = Move { from::Square, to::Square, promotion: Maybe Piece, nextPosition}
    * ðŸ™‚General enough
    * ðŸ™‚from, to, and promotion will help to debug
* âŒdata Move = Move {nextPosition, stringRepresentation}
    * ðŸ˜¡Move generator will need to know about string representation
* âŒtype Move = nextPosition
    * ðŸ™‚Very cool and general
    * ðŸ˜¡Hard to debug
* âœ…YAGNI right now, Move { from, to }

**How to name Position in move?**
* âŒnextPosition
    * ðŸ˜¡Unclear, not a verb
* âŒâœ…positionAfter
    * ðŸ™‚Reads nice: positionAfter move
    * ðŸ˜¡Not a verb
* âŒchangePosition
    * ðŸ˜¡Reads bad: changePosition move
* âŒchange
    * ðŸ˜¡Unclear
    * ðŸ˜¡Reads bad: change move
* âŒapply
    * ðŸ˜¡Not specific
* âŒâœ…make
    * ðŸ™‚Reads nice: make move
    * ðŸ˜¡It's not actually make, position is already exists
    * ðŸ˜¡Not terribly specific
* âœ…YAGNI right now

**How does move generator look like?**
* âŒmoves :: Position -> List[Move]
    * ðŸ˜¡Reads unclear
* âŒmovesFrom :: Position -> List[Move]
    * ðŸ™‚Reads nice
    * ðŸ˜¡Not a verb
* âœ…generateMoves :: Position -> List[Move]
    * ðŸ™‚Specific
    * ðŸ˜¡Long

**How to generate moves**?
âœ…
```haskell
generateMoves position =
    [
        move |
        (piece, square) <- piecesInSquares position
        move <- generatePieceMoves position piece square
    ]
```
* ðŸ™‚Clear

âŒSame as previous but using assocs instead of piecesInSquares
* ðŸ˜¡Not as readable
* ðŸ˜¡Need to filter out Nothing from pieces


**What's the alternative to the generateMoves name?**
* âŒmoves
    * ðŸ™‚Short
    * ðŸ˜¡Probably will clash with var name
* âœ…allMoves
    * ðŸ™‚Will play nicely with pieceMoves, pawnMoves, rookMoves 
* âŒgenerateMoves
    * ðŸ™‚Specific
    * ðŸ˜¡Too long
* âŒgenMoves
    * ðŸ˜¡Unclear