**0..7 or 1..8 for Board indices?**

* âŒ0..7
    * ğŸ™‚Zero-based indexing is more common 
    * ğŸ˜¡Not as on real board
* âœ…1..8
    * ğŸ™‚Same as on real board
    * ğŸ™‚Looks like one-based indexing is not bad here and plays nicely with inclusive ranges in Haskell
    * ğŸ˜¡One-based indexing

**How to name which side is to move in Position?**

* âœ…sideToMove
    * ğŸ™‚Clear and most popular
    * ğŸ˜¡Pretty long
* âŒtoMove
    * ğŸ˜¡Unclear
* âŒmoveOrder
    * ğŸ˜¡Unclear
    * ğŸ˜¡Reads like a verb
* âŒactiveSide
    * ğŸ˜¡Unclear

**How to represent move**?
* âŒdata Move = Move Square Square
    * ğŸ˜¡Move can change castling, en passant etc
* âŒdata Move = Move Square Square | Castle | 
    * ğŸ˜¡What about en passant etc?
* âŒdata Move = Move { from::Square, to::Square, isCapture::Bool, castleModifiers, ...}
    * ğŸ˜¡There are gonna be many modifiers
* âŒâœ…data Move = Move { from::Square, to::Square, promotion: Maybe Piece, Position}
    * ğŸ™‚General enough
    * ğŸ™‚from, to, and promotion will help to debug
* âŒdata Move = Move {Position -> Position, stringRepresentation}
    * ğŸ˜¡Move generator will need to know about string representation
* âŒtype Move = Position
    * ğŸ™‚Very cool and general
    * ğŸ˜¡Hard to debug
* âœ…YAGNI right now

**How to name Position in move?**
* âŒnextPosition
    * ğŸ˜¡Unclear, not a verb
* âŒâœ…positionAfter
    * ğŸ™‚Reads nice: positionAfter move
    * ğŸ˜¡Not a verb
* âŒchangePosition
    * ğŸ˜¡Reads bad: changePosition move
* âŒchange
    * ğŸ˜¡Unclear
    * ğŸ˜¡Reads bad: change move
* âŒapply
    * ğŸ˜¡Not specific
* âŒâœ…make
    * ğŸ™‚Reads nice: make move
    * ğŸ˜¡It's not actually make, position is already exists
    * ğŸ˜¡Not terribly specific
* âœ…YAGNI right now