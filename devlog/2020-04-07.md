**0..7 or 1..8 for Board indices?**

* ❌0..7
    * 🙂Zero-based indexing is more common 
    * 😡Not as on real board
* ✅1..8
    * 🙂Same as on real board
    * 🙂Looks like one-based indexing is not bad here and plays nicely with inclusive ranges in Haskell
    * 😡One-based indexing

**How to name which side is to move in Position?**

* ✅sideToMove
    * 🙂Clear and most popular
    * 😡Pretty long
* ❌toMove
    * 😡Unclear
* ❌moveOrder
    * 😡Unclear
    * 😡Reads like a verb
* ❌activeSide
    * 😡Unclear

**How to represent move**?
* ❌data Move = Move Square Square
    * 😡Move can change castling, en passant etc
* ❌data Move = Move Square Square | Castle | 
    * 😡What about en passant etc?
* ❌data Move = Move { from::Square, to::Square, isCapture::Bool, castleModifiers, ...}
    * 😡There are gonna be many modifiers
* ❌✅data Move = Move { from::Square, to::Square, promotion: Maybe Piece, Position}
    * 🙂General enough
    * 🙂from, to, and promotion will help to debug
* ❌data Move = Move {Position -> Position, stringRepresentation}
    * 😡Move generator will need to know about string representation
* ❌type Move = Position
    * 🙂Very cool and general
    * 😡Hard to debug
* ✅YAGNI right now

**How to name Position in move?**
* ❌nextPosition
    * 😡Unclear, not a verb
* ❌✅positionAfter
    * 🙂Reads nice: positionAfter move
    * 😡Not a verb
* ❌changePosition
    * 😡Reads bad: changePosition move
* ❌change
    * 😡Unclear
    * 😡Reads bad: change move
* ❌apply
    * 😡Not specific
* ❌✅make
    * 🙂Reads nice: make move
    * 😡It's not actually make, position is already exists
    * 😡Not terribly specific
* ✅YAGNI right now