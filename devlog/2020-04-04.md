**FilePath or Logger?**
* âŒFilePath
    * ğŸ™‚Simple
    * ğŸ˜¡Hard to test
* âœ…Logger
    * ğŸ™‚Can be tested
    * ğŸ˜¡Extra abstration


**How does the `play` function look like?**

âŒ
```haskell
play :: Player -> Logger -> IO ()
play player log =
    forever do
        input <- getLine
        logInput log input
        response = getResponse player (parse input)
        logResponse log response
        printResponse

getResponse :: Player -> Command -> IO Response
getResponse player command = do
    case command of
        Uci -> return uciOkResponse
        IsReady -> return readyOkResponse
        UciNewGame -> return emptyResponse
        Position -> return emptyResponse
        Go -> move player
```
* ğŸ™‚Clear code
* ğŸ˜¡Hard to test input/output of commands/responses

âŒ
```haskell
play :: Player -> Logger -> IO ()
play player log =
    input <- getContents
    responses <- mapM getResponse (map parse (lines input))
    mapM printResponses responses
```
* ğŸ˜¡Looks impossible

âœ… 
```haskell
play :: SomeIO :: Player -> IO ()

-- rest is the same as the first variant
```
* ğŸ™‚Clear code
* ğŸ™‚Can be tested


**How to name SomeIO?**

* âŒUciIO
    * ğŸ˜¡Stuttering, module is already named Uci
* âŒIO
    * ğŸ˜¡Clashes with system IO
* âŒInputOutput
    * ğŸ˜¡What's the difference from the system IO?
* âŒInOut
    * ğŸ˜¡What's the difference from the the system IO?
* âŒReaderWriter
    * ğŸ˜¡Hate it
* âŒReader & Writer (two arguments)
    * ğŸ˜¡Function will have 4 arguments, that's too much
* âŒReader & Writer with logging incorporated
    * ğŸ˜¡Not specific
* âŒInput & Output (two arguments) with logging incorporated
    * ğŸ˜¡Not specific
* âœ…CommandReader & ResponseWriter with logging incorporated
    * ğŸ™‚specific


**What's the definition of CommandReader type class?**
* âœ…read :: a -> IO Command
* âŒreadCommand :: a -> IO Command
    * ğŸ˜¡Stuttering


**What's Uci.Response?**
* âŒalias for [String]
    * ğŸ˜¡No type checks
* âœ…data Response = Response [String]
    * ğŸ™‚Simplest way
    * ğŸ™‚Command is Data, so it should also be Data
* newtype
    * ğŸ˜¡Same as data, but strict, I don't need that
* âŒsame as all previous, but String instead of [String]
    * ğŸ˜¡Can't represent both no Response and empty string Response  with that

**What's the definition of Player type class?**
* âŒmove :: a -> IO Response
    * ğŸ˜¡It doesn't actually moves
* âŒmakeMove
    * ğŸ˜¡It doesn't actually makes a move
* âŒbestMove
    * ğŸ™‚Specific and precise
    * ğŸ˜¡Not a verb
* âŒfindBestMove :: a -> IO Response
    * ğŸ™‚*Really* specific and precise
    * ğŸ™‚It's a verb!
    * ğŸ˜¡IO Response is not a move
* âœ…findBestMove :: a -> IO String
    * ğŸ™‚best of all possible worlds, later String will be changed to some Move type


**How to DRY Uci.getResponse tests?**
* âœ…Uci.Go `responseShouldBe` Uci.Response ["bestmove e2e4"]
    * ğŸ™‚Looks super nice
* âŒMorphy Uci.Go `responseShouldBe` Uci.Response ["bestmove e2e4"]
    * ğŸ˜¡Morphy is constant in all tests


**How to deal with quit?**
* âœ…Quit play function
    * ğŸ™‚Testable
* âŒUse some system quit
    * ğŸ˜¡Impossible to test


**Type classes or functions?**
* âŒType classes
    * ğŸ˜¡Your type classes are glorified functions
* âœ…Functions
    * ğŸ™‚Looks like simplest way


**Names for CommandReader and ResponseWriter instances?**
* âŒreadCommandWithLog
    * ğŸ˜¡Logging part of implementation and is seen in signature anyway
* âŒloggingReadCommand
    * ğŸ˜¡Same as readCommandWithLog
* âŒreadCommand
    * ğŸ™‚Short and clear
    * ğŸ˜¡Don't like that it's a verb
* âŒreadStdinCommand
    * ğŸ˜¡Uci always reads from stdin
* âœ…stdinReader
    * ğŸ™‚Noun & short


**player or findBestMove?**
* âœ…player
    * ğŸ™‚move <- player actually looks nice: "get the move from player"
* âŒfindBestMove
    * ğŸ˜¡inconsistent with nouns for reader & writer

**How to write play test so functions return different values?**
```haskell

```

**What to do with Uci.Unknown in getResponse?**
* Error
* Log & error
* Remove Uci.Unknown and fail earlier
