**What's the board represenation?**

* âœ…Immutable 8x8 array
    * ğŸ™‚Reflects reality, obvious choice
* âŒlist of lists
    * ğŸ™‚Haskell is good at lists
    * ğŸ˜¡O(n) complexity of getting item. Well it's actually O(16), still not great :)
* âŒlarger than 8x8 array
    * ğŸ˜¡I don't quite understand how it makes the code better. And I don't want to read it right now because first stage should be done by using only my head.
* âŒbitboards
    * ğŸ˜¡Harder to implement
    * ğŸ˜¡Speed is not needed right now
* Mutable array
    * ğŸ˜¡Looks like premature optimization


**What's the Position representation?**

* âœ…Record Position {board, whiteCastlingRight, blackCastling, moveOrder, enPassant, 50moves, history}
    * ğŸ™‚Clear and simple
* âŒSame as previous, but ADT
    * ğŸ˜¡Extracting fields will be painful


**What's the Piece represenation?**
* âœ…data Piece = Pawn Color | Knight Color | ...
    * ğŸ™‚Reflects reality: all pieces are colored in real life
    * ğŸ˜¡Reads backwards Pawn White, I would prefer White Pawn (could be solved with some operator White <> Pawn)
* âŒdata Piece = Pawn | Knight | ...
    * ğŸ˜¡It doesn't look like there'll be a place in code where color is irrelevant
* âŒpawn = 0, knight = 1
    * ğŸ˜¡ugly and no advantages
* âŒdata Piece = Record {kind, color}
    * ğŸ˜¡Still not readable enough
* data PieceKind = Pawn | Knight
* âŒdata Piece = White PieceKind | Black PieceKind
    * ğŸ™‚Looks great White Knight
    * ğŸ˜¡Color abstraction is lost
* âŒMake Color a function somehow
    * ğŸ˜¡Doesn't look possible


**What's the color representation?**
* âœ…data Color = Black | White
    * ğŸ™‚Simple and clear
* âŒblack = 0, white = 1
    * ğŸ˜¡ugly