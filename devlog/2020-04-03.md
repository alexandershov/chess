**What are UCI types?**

* ❌Uci.Input & Uci.Output
    * 😡Uci.Command & Uci.Response are more specific
* ✅Uci.Command & Uci.Response
    * 🙂Clear names
    * 🙂Extra type checking: we can't return Uci.Command in response
* ❌Uci.Command for everything
    * 🙂Simple
    * 😡No type checking, we can return illegal Uci.Command (like go) in response
* ❌Uci.Line for everything
    * 😡Uci.Command is more specific name

**Uci.parse or Uci.parseCommand?**

* ✅Uci.parse
    * 🙂Looks nice
    * 😡Parse what exactly?
* ❌Uci.parseCommand
    * 🙂Specific
    * 😡Type in name

**How to represent UCI commands with arguments?**

* ❌Position [String]
    * 😡Right now you don't need arguments
* ❌Position String
    * 😡Right now you don't need arguments
* ✅Position
    * 🙂Right now you don't need arguments

**How to parse UCI commands with arguments?**
* ❌Data.List.isPrefixOf with guards on the whole string
    * 😡Harder to parse commands with optional arguments
* ❌Data.List.isPrefixOf with guards on words of the string
    * 😡Looks less elegant than pattern match
* ✅Pattern match on words
    * 🙂Looks clean
* ❌'p':'r':'e':'f':'i':'x'
    * 😡Come on! You're better than this!

**What's the interface for one game cycle?**
* ❌Uci.Command -> Player -> IO Uci.Response
    * 🙂Player is more explicit than a function
    * 😡We'll have some useless serialization code compared to [String]
* ❌Uci.Command -> (Uci.Command -> IO Uci.Response) -> IO Uci.Response
    * 😡Passing function looks less elegant
* ✅[String] instead of Uci.Response
    * 🙂Simplest way!
