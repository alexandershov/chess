**What are UCI types?**

* âŒUci.Input & Uci.Output
    * ðŸ˜¡Uci.Command & Uci.Response are more specific
* âœ…Uci.Command & Uci.Response
    * ðŸ™‚Clear names
    * ðŸ™‚Extra type checking: we can't return Uci.Command in response
* âŒUci.Command for everything
    * ðŸ™‚Simple
    * ðŸ˜¡No type checking, we can return illegal Uci.Command (like go) in response
* âŒUci.Line for everything
    * ðŸ˜¡Uci.Command is more specific name

**Uci.parse or Uci.parseCommand?**

* âœ…Uci.parse
    * ðŸ™‚Looks nice
    * ðŸ˜¡Parse what exactly?
* âŒUci.parseCommand
    * ðŸ™‚Specific
    * ðŸ˜¡Type in name

**How to represent UCI commands with arguments?**

* âŒPosition [String]
    * ðŸ˜¡Right now you don't need arguments
* âŒPosition String
    * ðŸ˜¡Right now you don't need arguments
* âœ…Position
    * ðŸ™‚Right now you don't need arguments

**How to parse UCI commands with arguments?**
* âŒData.List.isPrefixOf with guards on the whole string
    * ðŸ˜¡Harder to parse commands with optional arguments
* âŒData.List.isPrefixOf with guards on words of the string
    * ðŸ˜¡Looks less elegant than pattern match
* âœ…Pattern match on words
    * ðŸ™‚Looks clean
* âŒ'p':'r':'e':'f':'i':'x'
    * ðŸ˜¡Come on! You're better than this!

**How does the game will look like?**
* âŒplay|game|session :: Player -> IO ()
    * ðŸ˜¡No logging
* âœ…play :: Player -> FilePath -> IO ()
    * ðŸ™‚Simple and complete
* âŒplay :: [Uci.Command] -> PLayer -> IO [[String]]
    * ðŸ˜¡It doesn't look possible, we can't get whole list of Uci.Command
    because they depend on our responses
* âŒplay :: [Uci.Command] -> Player -> [[String]] | [Uci.Response]
    * ðŸ˜¡This looks impossible, because we need to do some IO

