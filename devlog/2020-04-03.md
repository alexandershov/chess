**What are UCI types?**

* âŒUci.Input & Uci.Output
    * ğŸ˜¡Uci.Command & Uci.Response are more specific
* âœ…Uci.Command & Uci.Response
    * ğŸ™‚Clear names
    * ğŸ™‚Extra type checking: we can't return Uci.Command in response
* âŒUci.Command for everything
    * ğŸ™‚Simple
    * ğŸ˜¡No type checking, we can return illegal Uci.Command (like go) in response
* âŒUci.Line for everything
    * ğŸ˜¡Uci.Command is more specific name

**Uci.parse or Uci.parseCommand?**

* âœ…Uci.parse
    * ğŸ™‚Looks nice
    * ğŸ˜¡Parse what exactly?
* âŒUci.parseCommand
    * ğŸ™‚Specific
    * ğŸ˜¡Type in name

**How to represent UCI commands with arguments?**

* âŒPosition [String]
    * ğŸ˜¡Right now you don't need arguments
* âŒPosition String
    * ğŸ˜¡Right now you don't need arguments
* âœ…Position
    * ğŸ™‚Right now you don't need arguments

**How to parse UCI commands with arguments?**
* âŒData.List.isPrefixOf with guards on the whole string
    * ğŸ˜¡Harder to parse commands with optional arguments
* âŒData.List.isPrefixOf with guards on words of the string
    * ğŸ˜¡Looks less elegant than pattern match
* âœ…Pattern match on words
    * ğŸ™‚Looks clean
* âŒ'p':'r':'e':'f':'i':'x'
    * ğŸ˜¡Come on! You're better than this!

**What's the interface for one game cycle?**
* âŒUci.Command -> Player -> IO Uci.Response
    * ğŸ™‚Player is more explicit than a function
    * ğŸ˜¡We'll have some useless serialization code compared to [String]
* âŒUci.Command -> (Uci.Command -> IO Uci.Response) -> IO Uci.Response
    * ğŸ˜¡Passing function looks less elegant
* âœ…[String] instead of Uci.Response
    * ğŸ™‚Simplest way!
